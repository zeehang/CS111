README for Lab2A

Question Answers:

2.1.1 - Causing conflicts
Why does it take many iterations before errors are seen?
    The process of adding and subtracting a number can be completed in a fairly quick fashion. Therefore there may not be 
    a race condition between different threads unless each one is performing a large number of operations - that will
    "expose" the critical section for a longer time.

Why does a significantly smaller number of iterations so seldom fail?
    The time to complete add takes a very small amount of time. Therefore, less iterations means less time in the critical
    section of the code, which means there's less time for a race condition to occur.

2.1.2 - Cost of yielding
Why are the --yield runs so much slower? Where is the additional time going? Is it possible to get valid per-operation timings
if we are using the --yield option? If so, explain how. If not, explain why not.
    Sched_yield works by forcing the current thread to relinquish the CPU, and runs a new thread (used in critical sections),
    this means that 1) the thread will be interrupted and will take longer to complete and 2) it leads to unncessary context
    switching between threads, which adds a lot of overhead time. Therefore, the per-operation timings will be inflated.

2.1.3 - measurement errors
Why does the average cost per operation drop with increasing iterations? If the cost per iteration is a function of the 
number of iterations, how do we know how many iterations to run (or what the "correct" cost is)?
    The cost of creating a thread is fixed. Therefore, the more iterations there are, the more that constant cost will be
    divided by. That's why the average cost per iteration drops. We need to run enough iterations to avoid the
    startup time that comes with running the program.

2.1.4 - costs of serialization
Why do all of the options perform similarly for low numbers of threads?
    There will be less threads competing for locks. With a low number, each thread is able to get it pretty easily. It's important
    to remember that the add is really fast computation, so there won't be much waiting.

Why do the three protected operations slow down as the number of threads rises?
    There will be more competition for each thread to recieve the lock. The add computation still takes a very small amount of time
    but the time each thread spends waiting for the lock will grow longer, increasing the time spent.

Why are spin-locks so expensive for large numbers of threads?
    A spin lock constantly checks or "spins" to see whether the lock is open. If you have an extremely large number of threads,
    then each one will constantly be spinning and using up CPU time, leading to a more expensive operation.

2.2.1 - scalability of mutex 
Compare the variation in time per protected operation vs the number of threads (for mutex-protected operations) in Part-1
and Part-2, commenting on the similarities/differences and offering explanations for them.
    As the number of threads increased in add, the time it took for mutex increased. In list however, 
    it remained relatively constant. It makes sense that the time would increase, as there are more threads
    that will be waiting on and competing for the lock. Perhaps in list, the pointer operations were performed
    more quickly, thus leading to less overhead and relatively constant increase in mutex time.

2.2.2 - scalability of spin locks
Compare the variation in time per protected operation vs the number of threads for mutex vs spin locks,
commenting on similarities/differences and offering explainations for them
    As the operations increased, the time it took for spinlock also increased. Spinlocks are very
    CPU intensive, so it makes sense that as the number of threads increased that it would take
    each thread more time to complete the operation. Generally speaking, the time taken for spinlock
    was higher than the time taken for mutex in the list operations. Spinlock is more CPU intensive.

Files contained:
    .c files - implementation of the spec
    .gp - used with gnuplot to generate the graphs
    .png files - graphs generated by gnuplot
    Makefile - contains options to make the files and also create graphs and run tests

